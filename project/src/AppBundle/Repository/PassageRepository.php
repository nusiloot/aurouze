<?php

namespace AppBundle\Repository;

use Doctrine\ODM\MongoDB\DocumentRepository;
use AppBundle\Manager\PassageManager;
/**
 * EtablissementRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
use MongoDate as MongoDate;
use AppBundle\Manager\EtablissementManager;
use AppBundle\Document\Contrat;

class PassageRepository extends DocumentRepository {

    public function findAllPlanifieByPeriodeAndIdentifiantTechnicien($startDate, $endDate, $technicien, $onlyNonImprime = false) {
        $mongoStartDate = new MongoDate(strtotime($startDate . " 00:00:00"));
        $mongoEndDate = new MongoDate(strtotime($endDate . " 23:59:59"));
        $query = $this->createQueryBuilder('Passage')
                ->field('dateDebut')->gte($mongoStartDate)
                ->field('dateDebut')->lte($mongoEndDate)
                ->field('dateFin')->gte($mongoStartDate)
                ->field('techniciens')->equals($technicien->getId())
                ->sort('dateDebut', 'asc');
        if ($onlyNonImprime) {
            $query->addOr($query->expr()->field('imprime')->equals(false));
            $query->addOr($query->expr()->field('imprime')->exists(false));
        }
        $query = $query->getQuery();

        return $query->execute();
    }

    public function findAllPlanifieByPeriode($startDate, $endDate, $onlyNonImprime = false) {
        $mongoStartDate = new MongoDate(strtotime($startDate));
        $mongoEndDate = new MongoDate(strtotime($endDate));
        $query = $this->createQueryBuilder('Passage')
                ->field('dateDebut')->gte($mongoStartDate)
                ->field('dateDebut')->lte($mongoEndDate)
                ->field('dateFin')->gte($mongoStartDate)
                ->sort('technicien', 'desc')
                ->sort('dateDebut', 'asc');
        if ($onlyNonImprime) {
        	$query->field('imprime')->equals(false);
        }
        $query = $query->getQuery();
        return $query->execute();
    }

    public function findAllErreurs() {
        $mongoEndDate = new MongoDate(strtotime("now"));
        $mongoStartDate = new MongoDate(strtotime("2016-01-01 00:00:00"));
        $query = $this->createQueryBuilder('Passage')
                ->field('statut')->equals(PassageManager::STATUT_PLANIFIE)
                ->field('dateFin')->lte($mongoEndDate)
                ->field('dateDebut')->gte($mongoStartDate)
                ->sort('dateDebut', 'asc');
        $query = $query->getQuery();
        return $query->execute();
    }

    public function findHistoriqueByEtablissementAndPrestationsAndNumeroContrat(Contrat $contrat, $etablissement, $prestations = array(), $limit = 2) {
        $passagesHistorique = array();

        $contratsNumArchive = $this->dm->getRepository('AppBundle:Contrat')->findByNumeroArchive($contrat->getNumeroArchive());
        $contratsNumArchiveArray = array();
        foreach ($contratsNumArchive as $contratNumArchive) {
            $contratsNumArchiveArray[$contratNumArchive->getId()] = $contratNumArchive->getId();
        }
        foreach ($prestations as $prestation) {
            $passages = array();
            foreach ($contratsNumArchiveArray as $idContrat) {
                $passages = array_merge($passages, $this->findBy(array('contrat' => $idContrat, 'etablissement' => $etablissement->getId(), 'statut' => PassageManager::STATUT_REALISE, 'prestations.identifiant' => $prestation->getIdentifiant()), array('dateDebut' => 'DESC'), $limit));
                foreach ($passages as $passage) {
                    $passagesHistorique[$passage->getDateDebut()->format('YmdHi') . "_" . $passage->getId()] = $passage;
                }
            }
        }

        krsort($passagesHistorique);

        $passagesHistorique = array_slice($passagesHistorique, 0, 2);

        return $passagesHistorique;
    }

    public function findOneByIdentifiantPassage($identifiantPassage) {

        return $this->findOneBy(
                        array('id' => 'PASSAGE-' . $identifiantPassage));
    }

    public function findOneByIdentifiantEtablissementAndIdentifiantPassage($identifiantEtb, $identifiantPassage) {

        return $this->findOneBy(
                        array('id' => 'PASSAGE-' . $identifiantEtb . '-' . $identifiantPassage));
    }

    public function findByEtablissementAndCreateAt($etablissementIdentifiant, $createAt) {
        return $this->findBy(
                        array('etablissementIdentifiant' => $etablissementIdentifiant, 'createAt' => $createAt));
    }

    public function findPassagesForEtablissement($etablissementIdentifiant) {
        $query = $this->createQueryBuilder('Passage')
                ->field('etablissementIdentifiant')->equals($etablissementIdentifiant)
                ->sort('datePrevision', 'desc')
                ->getQuery();
        return$query->execute();
    }

    public function findPassagesForEtablissementSortedByContrat($etablissementIdentifiant) {
        $query = $this->createQueryBuilder('Passage')
                ->field('etablissementIdentifiant')->equals($etablissementIdentifiant)
                ->sort('contratId', 'desc')->sort('dateCreation', 'desc')
                ->getQuery();
        return $query->execute();
    }

    public function findByQuery($q)
    {
        $q = str_replace(",", "", $q);
        $q = "\"".str_replace(" ", "\" \"", $q)."\"";
        $resultSet = array();
        $itemResultSet = $this->getDocumentManager()->getDocumentDatabase('AppBundle:Passage')->command([
                'find' => 'Passage',
                'filter' => ['$text' => ['$search' => $q]],
                'projection' => ['score' => [ '$meta' => "textScore" ]],
                'sort' => ['score' => [ '$meta' => "textScore" ]],
                'limit' => 100

        ]);
        if (isset($itemResultSet['cursor']) && isset($itemResultSet['cursor']['firstBatch'])) {
            foreach ($itemResultSet['cursor']['firstBatch'] as $itemResult) {
                $resultSet[] = array("doc" => $this->uow->getOrCreateDocument('\AppBundle\Document\Passage', $itemResult), "score" => $itemResult['score']);
            }
        }
        return $resultSet;
    }

    public function findTechniciens() {
        $techniciens = array();
        $date = new \DateTime();
        $mongoEndDate = new MongoDate(strtotime($date->format('Y-m-d')));
        $date->modify('-2 month');
        $mongoStartDate = new MongoDate(strtotime($date->format('Y-m-d')));
        $query = $this->createQueryBuilder('Passage')
                ->field('dateFin')->gte($mongoStartDate)
                ->field('dateFin')->lte($mongoEndDate)
                ->group(array('technicien' => 1), array('count' => 0))
                ->reduce('function (obj, prev) { prev.count++; }')
                ->getQuery();
        $result = $query->execute();

        if (count($result)) {
            foreach ($result as $item) {
                $techniciens[$item['technicien']] = $item['technicien'];
            }
        }

        ksort($techniciens);

        return $techniciens;
    }

    public function findToPlan($secteur = EtablissementManager::SECTEUR_PARIS, \DateTime $dateDebut = null, \DateTime $dateFin) {
        $date = new \DateTime();
        $mongoEndDate = new MongoDate(strtotime($dateFin->format('Y-m-d')));

        $q = $this->createQueryBuilder();
        $q->field('statut')->equals(PassageManager::STATUT_A_PLANIFIER)
                ->field('datePrevision')->lte($mongoEndDate);

        if($dateDebut){
          $mongoStartDate = new MongoDate(strtotime($dateDebut->format('Y-m-d')));
          $q->field('datePrevision')->gte($mongoStartDate);

        }

        $regex = $this->getRegexForSeineEtMarne();
        if ($secteur == EtablissementManager::SECTEUR_PARIS) {
           $q->addAnd($q->expr()->field('etablissementInfos.adresse.codePostal')->operator('$not', new \MongoRegex($regex)));
        } else {
           $q->addAnd($q->expr()->field('etablissementInfos.adresse.codePostal')->equals(new \MongoRegex($regex)));
        }
        $query = $q->sort('etablissementInfos.adresse.codePostal', 'asc')->getQuery();

        return $query->execute();
    }

    public function findNbPassagesToPlanPerMonthUntil($secteur = EtablissementManager::SECTEUR_PARIS, \DateTime $dateFin){
      $date = new \DateTime();

      $datePlusOnemonth = clone $date;
      $datePlusOnemonth->modify("+1 month");

      $mongoEndDate = new MongoDate(strtotime($dateFin->format('Y-m-d')));

      $q = $this->createQueryBuilder();

      $q->field('statut')->equals(PassageManager::STATUT_A_PLANIFIER)
              ->field('datePrevision')->lte($mongoEndDate);
      $regex = $this->getRegexForSeineEtMarne();
      if ($secteur == EtablissementManager::SECTEUR_PARIS) {
         $q->addAnd($q->expr()->field('etablissementInfos.adresse.codePostal')->operator('$not', new \MongoRegex($regex)));
      } else {
         $q->addAnd($q->expr()->field('etablissementInfos.adresse.codePostal')->equals(new \MongoRegex($regex)));
      }
      $query = $q->sort('datePrevision', 'asc')->getQuery();

      $passages = $query->execute();
      $result = array();
      $result['courant'] = new \stdClass();
      $result['courant']->date = $date;
      $result['courant']->nb = 0;
      foreach ($passages as $passage) {
          $moisAnnee = $passage->getDatePrevision()->format('Ym');
          if (!array_key_exists($moisAnnee, $result)) {
              $result[$moisAnnee] = new \stdClass();
              $result[$moisAnnee]->nb = 0;
              $result[$moisAnnee]->date = $passage->getDatePrevision();
          }
          if($datePlusOnemonth > $passage->getDatePrevision()){
            $result['courant']->nb = $result['courant']->nb + 1;
          }
          $result[$moisAnnee]->nb = $result[$moisAnnee]->nb + 1;
      }
      return $result;
    }

    public function findAllPassagesForTechnicien(\DateTime $date, $technicien = null)
    {
      $mongoStartDate = new MongoDate(strtotime($date->format("Y-m-d") . " 00:00:00"));
      $mongoEndDate = new MongoDate(strtotime($date->format("Y-m-d") . " 23:59:59"));
      $queryBuilder = $this->createQueryBuilder('Passage');
      $query = $queryBuilder->field('dateFin')->notEqual(null)
              ->field('dateDebut')->gte($mongoStartDate)
              ->field('dateDebut')->lte($mongoEndDate);
      if($technicien){
          $queryBuilder->field('techniciens')->equals($technicien->getId());
      }
      $queryBuilder->sort('dateDebut', 'asc');
      $query = $queryBuilder->getQuery();

      return $query->execute();
    }


    public function findLastDateModificationPassagesForTechnicien($technicien, $date){

      $mongoStartDate = new MongoDate(strtotime($date . " 00:00:00"));
      $mongoEndDate = new MongoDate(strtotime($date." 23:59:59"));
      $queryBuilder = $this->createQueryBuilder('Passage');
      $query = $queryBuilder->field('dateFin')->notEqual(null)
              ->field('dateDebut')->gte($mongoStartDate)
              ->field('dateDebut')->lte($mongoEndDate)
              ->field('techniciens')->equals($technicien);

      $queryBuilder->sort('dateModification', 'desc');
      $query = $queryBuilder->getQuery();
      $resultPassage = $query->execute();
      foreach ($resultPassage as $passage) {
        if($passage->getDateModification()){
          return $passage->getDateModification()->format("YmdHis");
        }
      }
      return "0";
    }

    public function countPassagesByTechnicien($compte) {

        return $this->createQueryBuilder()
                        ->field('techniciens')->equals($compte->getId())
                        ->getQuery()->execute()->count();
    }

    public function findAllNettoyages() {
        $request = $this->createQueryBuilder()
                ->distinct('nettoyages')
                ->hydrate(false)
                ->getQuery()
                ->execute();
        return $request->toArray();
    }

    public function findAllApplications() {
        return PassageManager::$applications;
    }

    private function getRegexForSeineEtMarne(){
      $dpts = EtablissementManager::$secteurs_departements[EtablissementManager::SECTEUR_SEINE_ET_MARNE];
      $regex = '';
      $dptReg = '';
      foreach ($dpts as $i => $dpt) {
          $dptReg .= $dpt;
          if ($i < count($dpts) - 1) {
              $dptReg .= '|';
          }
      }
      $regex .= '/^(' . $dptReg . ')/i';
      return $regex;
    }

}
